// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bledata.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017, Paul DeMarco.
// All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum LogLevelMessage: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case verbose // = 0
  case debug // = 1
  case info // = 2
  case warning // = 3
  case error // = 4
  case none // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .verbose
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .verbose
    case 1: self = .debug
    case 2: self = .info
    case 3: self = .warning
    case 4: self = .error
    case 5: self = .none
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .verbose: return 0
    case .debug: return 1
    case .info: return 2
    case .warning: return 3
    case .error: return 4
    case .none: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

enum BluetoothStateMessage: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case resetting // = 1
  case unsupported // = 2
  case unauthorized // = 3
  case poweredOff // = 4
  case poweredOn // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .resetting
    case 2: self = .unsupported
    case 3: self = .unauthorized
    case 4: self = .poweredOff
    case 5: self = .poweredOn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .resetting: return 1
    case .unsupported: return 2
    case .unauthorized: return 3
    case .poweredOff: return 4
    case .poweredOn: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

struct ScanDataMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scanMode: Int32 = 0

  var callbackType: Int32 = 0

  var uuids: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BleDeviceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var rssi: Int32 = 0

  var mtu: Int32 = 0

  var isConnected: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ScanResultMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bleDeviceMessage: BleDeviceMessage {
    get {return _storage._bleDeviceMessage ?? BleDeviceMessage()}
    set {_uniqueStorage()._bleDeviceMessage = newValue}
  }
  /// Returns true if `bleDeviceMessage` has been explicitly set.
  var hasBleDeviceMessage: Bool {return _storage._bleDeviceMessage != nil}
  /// Clears the value of `bleDeviceMessage`. Subsequent reads from it will return its default value.
  mutating func clearBleDeviceMessage() {_storage._bleDeviceMessage = nil}

  var rssi: Int32 {
    get {return _storage._rssi}
    set {_uniqueStorage()._rssi = newValue}
  }

  var timestampNanos: UInt64 {
    get {return _storage._timestampNanos}
    set {_uniqueStorage()._timestampNanos = newValue}
  }

  var scanCallbackTypeMessage: Int32 {
    get {return _storage._scanCallbackTypeMessage}
    set {_uniqueStorage()._scanCallbackTypeMessage = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ConnectToDeviceDataMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var macAddress: String = String()

  var isAutoConnect: Bool = false

  var requestMtu: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ServiceMessages {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceMessages: [ServiceMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ServiceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Double {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var device: BleDeviceMessage {
    get {return _storage._device ?? BleDeviceMessage()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {_storage._device = nil}

  var isPrimary: Bool {
    get {return _storage._isPrimary}
    set {_uniqueStorage()._isPrimary = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CharacteristicMessages {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristicMessage: [CharacteristicMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CharacteristicMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Double = 0

  var uuid: String = String()

  var serviceID: Int32 = 0

  var serviceUuid: String = String()

  var deviceID: String = String()

  var isReadable: Bool = false

  var isWritableWithResponse: Bool = false

  var isWritableWithoutResponse: Bool = false

  var isNotificable: Bool = false

  var isIndicatable: Bool = false

  var isNotifing: Bool = false

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MonitorCharacteristicMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String {
    get {return _storage._transactionID}
    set {_uniqueStorage()._transactionID = newValue}
  }

  var characteristicMessage: CharacteristicMessage {
    get {return _storage._characteristicMessage ?? CharacteristicMessage()}
    set {_uniqueStorage()._characteristicMessage = newValue}
  }
  /// Returns true if `characteristicMessage` has been explicitly set.
  var hasCharacteristicMessage: Bool {return _storage._characteristicMessage != nil}
  /// Clears the value of `characteristicMessage`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristicMessage() {_storage._characteristicMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension LogLevelMessage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERBOSE"),
    1: .same(proto: "DEBUG"),
    2: .same(proto: "INFO"),
    3: .same(proto: "WARNING"),
    4: .same(proto: "ERROR"),
    5: .same(proto: "NONE"),
  ]
}

extension BluetoothStateMessage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "RESETTING"),
    2: .same(proto: "UNSUPPORTED"),
    3: .same(proto: "UNAUTHORIZED"),
    4: .same(proto: "POWERED_OFF"),
    5: .same(proto: "POWERED_ON"),
  ]
}

extension ScanDataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ScanDataMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scanMode"),
    2: .same(proto: "callbackType"),
    3: .same(proto: "uuids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.scanMode)
      case 2: try decoder.decodeSingularInt32Field(value: &self.callbackType)
      case 3: try decoder.decodeRepeatedStringField(value: &self.uuids)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scanMode != 0 {
      try visitor.visitSingularInt32Field(value: self.scanMode, fieldNumber: 1)
    }
    if self.callbackType != 0 {
      try visitor.visitSingularInt32Field(value: self.callbackType, fieldNumber: 2)
    }
    if !self.uuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uuids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ScanDataMessage) -> Bool {
    if self.scanMode != other.scanMode {return false}
    if self.callbackType != other.callbackType {return false}
    if self.uuids != other.uuids {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension BleDeviceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BleDeviceMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "rssi"),
    4: .same(proto: "mtu"),
    5: .same(proto: "isConnected"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularInt32Field(value: &self.rssi)
      case 4: try decoder.decodeSingularInt32Field(value: &self.mtu)
      case 5: try decoder.decodeSingularBoolField(value: &self.isConnected)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.rssi != 0 {
      try visitor.visitSingularInt32Field(value: self.rssi, fieldNumber: 3)
    }
    if self.mtu != 0 {
      try visitor.visitSingularInt32Field(value: self.mtu, fieldNumber: 4)
    }
    if self.isConnected != false {
      try visitor.visitSingularBoolField(value: self.isConnected, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: BleDeviceMessage) -> Bool {
    if self.id != other.id {return false}
    if self.name != other.name {return false}
    if self.rssi != other.rssi {return false}
    if self.mtu != other.mtu {return false}
    if self.isConnected != other.isConnected {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ScanResultMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ScanResultMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bleDeviceMessage"),
    2: .same(proto: "rssi"),
    3: .same(proto: "timestampNanos"),
    4: .same(proto: "scanCallbackTypeMessage"),
  ]

  fileprivate class _StorageClass {
    var _bleDeviceMessage: BleDeviceMessage? = nil
    var _rssi: Int32 = 0
    var _timestampNanos: UInt64 = 0
    var _scanCallbackTypeMessage: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _bleDeviceMessage = source._bleDeviceMessage
      _rssi = source._rssi
      _timestampNanos = source._timestampNanos
      _scanCallbackTypeMessage = source._scanCallbackTypeMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._bleDeviceMessage)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._rssi)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._timestampNanos)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._scanCallbackTypeMessage)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._bleDeviceMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._rssi != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rssi, fieldNumber: 2)
      }
      if _storage._timestampNanos != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestampNanos, fieldNumber: 3)
      }
      if _storage._scanCallbackTypeMessage != 0 {
        try visitor.visitSingularInt32Field(value: _storage._scanCallbackTypeMessage, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ScanResultMessage) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._bleDeviceMessage != other_storage._bleDeviceMessage {return false}
        if _storage._rssi != other_storage._rssi {return false}
        if _storage._timestampNanos != other_storage._timestampNanos {return false}
        if _storage._scanCallbackTypeMessage != other_storage._scanCallbackTypeMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ConnectToDeviceDataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConnectToDeviceDataMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macAddress"),
    2: .same(proto: "isAutoConnect"),
    3: .same(proto: "requestMtu"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.macAddress)
      case 2: try decoder.decodeSingularBoolField(value: &self.isAutoConnect)
      case 3: try decoder.decodeSingularInt32Field(value: &self.requestMtu)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 1)
    }
    if self.isAutoConnect != false {
      try visitor.visitSingularBoolField(value: self.isAutoConnect, fieldNumber: 2)
    }
    if self.requestMtu != 0 {
      try visitor.visitSingularInt32Field(value: self.requestMtu, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ConnectToDeviceDataMessage) -> Bool {
    if self.macAddress != other.macAddress {return false}
    if self.isAutoConnect != other.isAutoConnect {return false}
    if self.requestMtu != other.requestMtu {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ServiceMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServiceMessages"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceMessages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.serviceMessages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceMessages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ServiceMessages) -> Bool {
    if self.serviceMessages != other.serviceMessages {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ServiceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServiceMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uuid"),
    3: .same(proto: "device"),
    4: .same(proto: "isPrimary"),
  ]

  fileprivate class _StorageClass {
    var _id: Double = 0
    var _uuid: String = String()
    var _device: BleDeviceMessage? = nil
    var _isPrimary: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _uuid = source._uuid
      _device = source._device
      _isPrimary = source._isPrimary
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._uuid)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._device)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._isPrimary)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularDoubleField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 2)
      }
      if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._isPrimary != false {
        try visitor.visitSingularBoolField(value: _storage._isPrimary, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ServiceMessage) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._id != other_storage._id {return false}
        if _storage._uuid != other_storage._uuid {return false}
        if _storage._device != other_storage._device {return false}
        if _storage._isPrimary != other_storage._isPrimary {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CharacteristicMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CharacteristicMessages"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristicMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.characteristicMessage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.characteristicMessage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristicMessage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: CharacteristicMessages) -> Bool {
    if self.characteristicMessage != other.characteristicMessage {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension CharacteristicMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CharacteristicMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uuid"),
    3: .same(proto: "serviceId"),
    4: .same(proto: "serviceUuid"),
    5: .same(proto: "deviceId"),
    6: .same(proto: "isReadable"),
    7: .same(proto: "isWritableWithResponse"),
    8: .same(proto: "isWritableWithoutResponse"),
    9: .same(proto: "isNotificable"),
    10: .same(proto: "isIndicatable"),
    11: .same(proto: "isNotifing"),
    12: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.uuid)
      case 3: try decoder.decodeSingularInt32Field(value: &self.serviceID)
      case 4: try decoder.decodeSingularStringField(value: &self.serviceUuid)
      case 5: try decoder.decodeSingularStringField(value: &self.deviceID)
      case 6: try decoder.decodeSingularBoolField(value: &self.isReadable)
      case 7: try decoder.decodeSingularBoolField(value: &self.isWritableWithResponse)
      case 8: try decoder.decodeSingularBoolField(value: &self.isWritableWithoutResponse)
      case 9: try decoder.decodeSingularBoolField(value: &self.isNotificable)
      case 10: try decoder.decodeSingularBoolField(value: &self.isIndicatable)
      case 11: try decoder.decodeSingularBoolField(value: &self.isNotifing)
      case 12: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularDoubleField(value: self.id, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    if self.serviceID != 0 {
      try visitor.visitSingularInt32Field(value: self.serviceID, fieldNumber: 3)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 4)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 5)
    }
    if self.isReadable != false {
      try visitor.visitSingularBoolField(value: self.isReadable, fieldNumber: 6)
    }
    if self.isWritableWithResponse != false {
      try visitor.visitSingularBoolField(value: self.isWritableWithResponse, fieldNumber: 7)
    }
    if self.isWritableWithoutResponse != false {
      try visitor.visitSingularBoolField(value: self.isWritableWithoutResponse, fieldNumber: 8)
    }
    if self.isNotificable != false {
      try visitor.visitSingularBoolField(value: self.isNotificable, fieldNumber: 9)
    }
    if self.isIndicatable != false {
      try visitor.visitSingularBoolField(value: self.isIndicatable, fieldNumber: 10)
    }
    if self.isNotifing != false {
      try visitor.visitSingularBoolField(value: self.isNotifing, fieldNumber: 11)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: CharacteristicMessage) -> Bool {
    if self.id != other.id {return false}
    if self.uuid != other.uuid {return false}
    if self.serviceID != other.serviceID {return false}
    if self.serviceUuid != other.serviceUuid {return false}
    if self.deviceID != other.deviceID {return false}
    if self.isReadable != other.isReadable {return false}
    if self.isWritableWithResponse != other.isWritableWithResponse {return false}
    if self.isWritableWithoutResponse != other.isWritableWithoutResponse {return false}
    if self.isNotificable != other.isNotificable {return false}
    if self.isIndicatable != other.isIndicatable {return false}
    if self.isNotifing != other.isNotifing {return false}
    if self.value != other.value {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension MonitorCharacteristicMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MonitorCharacteristicMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionId"),
    2: .same(proto: "characteristicMessage"),
  ]

  fileprivate class _StorageClass {
    var _transactionID: String = String()
    var _characteristicMessage: CharacteristicMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionID = source._transactionID
      _characteristicMessage = source._characteristicMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._transactionID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._characteristicMessage)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transactionID, fieldNumber: 1)
      }
      if let v = _storage._characteristicMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: MonitorCharacteristicMessage) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._transactionID != other_storage._transactionID {return false}
        if _storage._characteristicMessage != other_storage._characteristicMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
